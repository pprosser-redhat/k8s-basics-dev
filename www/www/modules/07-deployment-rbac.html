<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled :: Kubernetes Basic Workshop</title>
    <link rel="canonical" href="https://github.com/pprosser-redhat/k8s-basics-dev.git/modules/07-deployment-rbac.html">
    <meta name="generator" content="Antora 3.1.12">
    <link rel="stylesheet" href="../_/css/site.css">
<link rel="icon" href="../_/img/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<script src="https://unpkg.com/clipboard@2/dist/clipboard.min.js"></script>
  </head>
  <body class="article">
<header class="header" role="banner">

</header>
<div class="main-wrapper">

  <main class="main">
<div class="toolbar" role="navigation">
</div><article class="doc">
<div class="paragraph">
<p>The application that we are about to deploy requires access to the Kubernetes API server, this is to enable the front end application (parksmap) to discover services running the backend. In our case, this is just National Parks, but other services can easily be added plotting different sites on our map without change to the front end application. The front end application uses the Kubernetes API server to discover services running in our cluster. In an Enterprise deployment of Kubernetes it is essential that RBAC (Role Based Access Control) is enabled on our cluster. Most Enterprise deployments of Kubernetes have RBAC enabled by default.</p>
</div>
<div class="paragraph">
<p>All objects in the Kubernetes cluster can have RBAC polices defined, this includes developers login into the cluster, and our applicaions that which to access services off the cluster.</p>
</div>
<div class="paragraph">
<p>In our use case, the parks map application needs view acccess to the Kubernetes API server to discover services running on the cluster.</p>
</div>
<div class="paragraph">
<p>Lets use 'kubectl' to define the policy ahead of deploying the application. This way, the application will not be hit by any authorisation issues.</p>
</div>
<div class="paragraph">
<p>In the terminal window, run the following command:</p>
</div>
<div class="listingblock console-input">
<div class="content">
<pre class="highlightjs highlight"><code class="language-execute hljs" data-lang="execute">kubectl create rolebinding parksmap-rolebinding --clusterrole=view --user=parksmap</code></pre>
</div>
</div>
<div class="paragraph">
<p>To view the <code>deployment</code> resource used for the front end web application, run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-execute hljs" data-lang="execute">cat frontend/deployment.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>This has various parts to it, as well as dependencies on other resources, so let&#8217;s start over and create this from scratch.</p>
</div>
<div class="paragraph">
<p>To create a new <code>deployment</code> resource what often happens is that a developer will copy an existing one, be it one from an existing application, or a sample provided in documentation or a blog post.</p>
</div>
<div class="paragraph">
<p>An alternative is to have <code>kubectl</code> create it for you. For a <code>deployment</code>, the <code>kubectl</code> command provides two options for creating the resource definition for you.</p>
</div>
<div class="paragraph">
<p>The first option is using the <code>kubectl create deployment</code> command.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-execute hljs" data-lang="execute">kubectl create deployment --help</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the deployment of the front end web application, the container image we want to use is <code>openshiftkatacoda/blog-django-py:latest</code>.</p>
</div>
<div class="paragraph">
<p>To see what <code>kubectl create deployment</code> would create for us run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-execute hljs" data-lang="execute">kubectl create deployment blog --image openshiftkatacoda/blog-django-py:latest --dry-run -o yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>This should yield:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: blog
  name: blog
spec:
  replicas: 1
  selector:
    matchLabels:
      app: blog
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: blog
    spec:
      containers:
      - image: openshiftkatacoda/blog-django-py:latest
        name: blog-django-py
        resources: {}
status: {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that nothing has been created at this point as when we ran <code>kubectl create deployment</code> we used the <code>--dry-run</code> option, it therefore only showed what it would create.</p>
</div>
<div class="paragraph">
<p>Although <code>kubectl create deployment</code> could be used, it is a very bare bones skeleton for a <code>deployment</code> object.</p>
</div>
<div class="paragraph">
<p>A second option is to use <code>kubectl run</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-execute hljs" data-lang="execute">kubectl run --help</code></pre>
</div>
</div>
<div class="paragraph">
<p>This command accepts numerous options for helping you fill out the resource definition with additional key configuration you might need.</p>
</div>
<div class="paragraph">
<p>To start to replicate the configuration for our sample application, run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-execute hljs" data-lang="execute">kubectl run blog --image openshiftkatacoda/blog-django-py:latest --labels app=blog --replicas 2 --port 8080 --env BLOG_SITE_NAME="OpenShift Blog" --dry-run -o yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>This should produce:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">apiVersion: apps/v1beta1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: blog
  name: blog
spec:
  replicas: 2
  selector:
    matchLabels:
      app: blog
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: blog
    spec:
      containers:
      - env:
        - name: BLOG_SITE_NAME
          value: OpenShift Blog
        image: openshiftkatacoda/blog-django-py:latest
        name: blog
        ports:
        - containerPort: 8080
        resources: {}
status: {}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The difference is that it has set the number of replicas of our application that we want to be 2 instead of 1. It includes the port number our application listens on, and includes one of the environment variables we want to be set. We have also ensured the label used is <code>app=blog</code>. This version of the <code>deployment</code> is still far from complete, but it is enough to get us started.</p>
</div>
<div class="paragraph">
<p>One could now re-run the command and leave off the <code>--dry-run</code> option and it would create the resource. To make subsequent changes to the resource definition, one could then edit it in place using the <code>kubectl edit</code> command.</p>
</div>
<div class="paragraph">
<p>Maintaining the master copy of the configuration in Kubernetes like this is fine in a development environment, but for production, it is better to keep the master copy as a local file, under revision control so you can track it, and when changes are needed, edit the local master copy and apply it to the Kubernetes cluster.</p>
</div>
<div class="paragraph">
<p>The Kubernetes documentation has a discussion about these two different approaches to managing configuration in [Managing Kubernetes Objects Using Imperative Commands](<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/imperative-command/" class="bare">https://kubernetes.io/docs/concepts/overview/object-management-kubectl/imperative-command/</a>) and [Declarative Management of Kubernetes Objects Using Configuration Files](<a href="https://kubernetes.io/docs/concepts/overview/object-management-kubectl/declarative-config/" class="bare">https://kubernetes.io/docs/concepts/overview/object-management-kubectl/declarative-config/</a>).</p>
</div>
<div class="paragraph">
<p>As it is closer to what you would want to do for a production environment, we will use the latter approach.</p>
</div>
<div class="paragraph">
<p>For this first attempt towards replicating the front end web application, the output from <code>kubectl run</code> has been captured in the file <code>frontend-v1/deployment.yaml</code>. You can see the full contents of the directory by running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-execute hljs" data-lang="execute">ls -las frontend-v1</code></pre>
</div>
</div>
<div class="paragraph">
<p>As is, it is only the one file. We could at this point run <code>kubectl apply</code> on just this file, but as we go along we will be adding additional files for other resources. We will therefore continue to use the ability of <code>kubectl apply</code> to be given a directory of files to process and apply them in one operation.</p>
</div>
<div class="paragraph">
<p>Create the <code>deployment</code> by running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-execute hljs" data-lang="execute">kubectl apply -f frontend-v1/</code></pre>
</div>
</div>
<div class="paragraph">
<p>It should output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">deployment.apps/blog created</code></pre>
</div>
</div>
<div class="paragraph">
<p>Monitor progress of the deployment so you know when it has completed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-execute hljs" data-lang="execute">kubectl rollout status deployment/blog</code></pre>
</div>
</div>
</article>
  </main>
</div>
<footer role="contentinfo">
  <div class="region region-rhd-footer">
    <div id="block-rhdfooter" class="rhd-footer">
      <nav class="rhd-footer-nav" aria-label="Secondary Navigation" role="navigation">
  <ul class="rhd-menu">
    
  </ul>
</nav>
    </div>
  </div>
</footer>
<script src="../_/js/site.js"></script>
<script src="../_/js/vendor/highlight.js"></script>
<script>hljs.initHighlighting()</script>
<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"
  integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js"
  integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js"
  integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
  </body>
</html>
