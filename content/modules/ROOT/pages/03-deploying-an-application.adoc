= Deploying an Application
:navtitle: Deploying an Application

include::vars.adoc[]

Now you have checked your access to the Kubernetes cluster is working, we are going to immediately jump in and deploy a complete application, consisting of a front end web application, a backend restful application, along with a MongoDB database for storing the worlds national parks in. Together, they will implement a site that maps the worlds national parks.

== Deploying an Application

This is to show you how quickly you can deploy a complete application to Kubernetes if you already have the configuration. Once the complete application has been deployed, we will delete the front end web application component, and deploy it again in steps so you can see how it fits together and how it uses Kubernetes.

=== Deploying the database

The first part of the application we want to deploy is the MongoDB database. The set of resource files for deploying this can be found in the `database` directory.

[source,role="copypaste",subs="attributes"]
----
ls -las database/
----

Each file in the directory contains a different resource definition which go together to make up the deployment for the application component.

Rather than try and dig into each file to work out what it defines, you can have Kubernetes tell you what resources it would create when the directory of resources is processed. To do this, run:

[source,role="copypaste",subs="attributes"]
----
kubectl apply -f database/ --dry-run=client
----

This should output:

[.console-output]
[source,subs="attributes"]
----
secret/blog-credentials created (dry run)
service/blog-db created (dry run)
persistentvolumeclaim/blog-database created (dry run)
deployment.apps/blog-db created (dry run)
----


The `kubectl apply` command in this case is what is used to create resources from a configuration file, or set of files contained in a directory. We used the `--dry-run=client` option, which says to tell us what would be created, but don't actually do it. The `--dry-run=client` option is useful because it will tell you what resources would be created, but also validates the resource definitions and will warn you if you have errors in them.

If you are ever uncertain about what a command does, or what options it accepts, you can run it with the `--help` option.

[source,execute]
----
kubectl apply --help
----

By doing a dry run deployment, you have seen the resources that will be created. To actually deploy the database component, now run:

[.console-input]
[source,execute]
----
kubectl apply -f database/
----

As with the dry run, `kubectl apply` will list the resources, except this time the resources will be created.

[.console-output]
[source]
----
secret/blog-credentials created
service/blog-db created
persistentvolumeclaim/blog-database created
deployment.apps/blog-db created
----

The key resource in this list is `deployment`. It specifies the name of the container image to be deployed for an application, how many instances should be started, and the strategy for how the deployment should be managed.

To monitor progress of the deployment, and know when it has completed, you can run the command:

[.console-input]
[source,execute]
----
kubectl rollout  status deployment/mongodb-community-server
----

The argument is the full name of the resource, including the type of resource and the name for this instance. In this case the instance was called `mongodb-community-server`.

=== Deploying the front end web application

With the database deployed, now deploy the front end web application by running:

[.console-input]
[source,execute]
----
kubectl apply -f frontend/
----

This should output:

[.console-output]
[source]
----
deployment.apps/parksmap created
ingress.networking.k8s.io/parksmap created
rolebinding.rbac.authorization.k8s.io/parksmap-view created
service/parksmap created
----

Run:

[.console-input]
[source,execute]
----
kubectl rollout status deployment/parksmap
----

to monitor and wait for it to be deployed.

In the resources created for the front end web application, the `ingress` is special, in that it is what sets up access to our web application using a public URL.

In this example, the URL for accessing the front end web application will be:

You need to substitute the `PROJECT_NAMESPACE` and `CLUSTER_SUBDOMAIN` variables with your own values.

http://parksmap-%project_namespace%.%cluster_subdomain%

This is easy to findout by running a query againts the parksmap ingress using `kubectl`:
[.console-input]
[source,execute]
----
kubectl get ingress parksmap -o=jsonpath='{.spec.rules[0]}' | jq
----

This should output something like this:
[.console-output]
[source]
----
{
  "host": "parksmap-user1-workshop.apps.cluster-5cbfd.dynamic.redhatworkshops.io",
  "http": {
    "paths": [
      {
        "backend": {
          "service": {
            "name": "parksmap",
            "port": {
              "number": 8080
            }
          }
        },
        "path": "/",
        "pathType": "Prefix"
      }
    ]
  }
}
----

The value of host is what you are after.

Visit the front end web application by typing (or copying).

[.console-input]
[source,execute]
----
http://parksmap-user1-workshop.apps.cluster-5cbfd.dynamic.redhatworkshops.io
----

into your browser (`Please make sure you use the host name from your cluster`)

It should look like:

[.bordershadow]
image::parksmap.png[link="self",window=_blank]

NOTE: There are no national parks displayed as yet. We still have to deploy the backend application, which is what we'll do next.

=== Deploy the backend restful application

With the front end web application deployed, now deploy the backend application by running:

[.console-input]
[source,execute]
----
kubectl apply -f ./backend/
----

This should output:

[.console-output]
[source]
----
deployment.apps/nationalparks-py created
ingress.networking.k8s.io/nationalparks-py created
service/nationalparks-py created
----

Run:

[.console-input]
[source,execute]
----
kubectl rollout status deployment/nationalparks-py
----

Now visit the front end web application again (make sure you refresh the page), and you'll notice that there are still no national parks displayed. This is because there is no data in the database yet. 

=== Load the data

Fortunately, the backend application has an API that we can use to load the data. Later, we'll look at how logging might have helped us work this out.

To load the data into the database, run:

[.console-input]
[source,execute]
----
curl http://nationalparks-py:8080/ws/data/load
----

This should output:

[.console-output]
[source]
----
"Items inserted in database: 2762"
----

As the terminal window is running in the same namespace as the nationalparks-py application on Kubernetes, it can access the kubernetes service directly hence no need for finding out the ingress host name to use (more later).


=== Let the fun begin!!!

You should now see a page similar to the one below:

Refresh the parksmap page in the `browser` and this time you should see national parks appearing on the map.

[.bordershadow]
image::parksmap-with-np.png[link="self",window=_blank]

Feel free to move around the map, zoom in and out, and click on national parks.


